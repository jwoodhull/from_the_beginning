// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");

function take(n, l) {
  if (l && n > 0) {
    return /* :: */[
            l[0],
            take(n - 1 | 0, l[1])
          ];
  } else {
    return /* [] */0;
  }
}

function drop(_n, _l) {
  while(true) {
    var l = _l;
    var n = _n;
    if (l && n > 0) {
      _l = l[1];
      _n = n - 1 | 0;
      continue ;
      
    } else {
      return l;
    }
  };
}

function $$double(l) {
  if (l) {
    return /* :: */[
            (l[0] << 1),
            $$double(l[1])
          ];
  } else {
    return /* [] */0;
  }
}

function map(f, l) {
  if (l) {
    return /* :: */[
            Curry._1(f, l[0]),
            map(f, l[1])
          ];
  } else {
    return /* [] */0;
  }
}

function halve(v) {
  return v / 2 | 0;
}

var greater = Caml_obj.caml_greaterequal;

function merge(cmp, x, y) {
  if (x) {
    if (y) {
      var hy = y[0];
      var hx = x[0];
      if (Curry._2(cmp, hx, hy)) {
        return /* :: */[
                hx,
                merge(cmp, x[1], y)
              ];
      } else {
        return /* :: */[
                hy,
                merge(cmp, x, y[1])
              ];
      }
    } else {
      return x;
    }
  } else {
    return y;
  }
}

function msort(cmp, l) {
  if (l) {
    if (l[1]) {
      var half = List.length(l) / 2 | 0;
      var left = take(half, l);
      var right = drop(half, l);
      return merge(cmp, msort(cmp, left), msort(cmp, right));
    } else {
      return /* :: */[
              l[0],
              /* [] */0
            ];
    }
  } else {
    return /* [] */0;
  }
}

function calm(l) {
  if (l) {
    var t = l[1];
    var h = l[0];
    if (h === /* "!" */33) {
      return /* :: */[
              /* "." */46,
              calm(t)
            ];
    } else {
      return /* :: */[
              h,
              calm(t)
            ];
    }
  } else {
    return /* [] */0;
  }
}

function calm2(param) {
  return map((function (c) {
                var match = +(c === /* "!" */33);
                if (match !== 0) {
                  return /* "." */46;
                } else {
                  return c;
                }
              }), param);
}

function clip(n) {
  if (n <= 1) {
    return 1;
  } else if (n >= 10) {
    return 10;
  } else {
    return n;
  }
}

function clipList(param) {
  return map(clip, param);
}

function apply(f, c, s) {
  if (c <= 0) {
    return s;
  } else {
    return Curry._1(f, apply(f, c - 1 | 0, s));
  }
}

function filter(f, _l) {
  while(true) {
    var l = _l;
    if (l) {
      var t = l[1];
      var h = l[0];
      if (Curry._1(f, h)) {
        return /* :: */[
                h,
                filter(f, t)
              ];
      } else {
        _l = t;
        continue ;
        
      }
    } else {
      return /* [] */0;
    }
  };
}

function for_all(f, _l) {
  while(true) {
    var l = _l;
    if (l) {
      if (Curry._1(f, l[0])) {
        _l = l[1];
        continue ;
        
      } else {
        return /* false */0;
      }
    } else {
      return /* true */1;
    }
  };
}

function mapl(f, l) {
  if (l) {
    return /* :: */[
            map(f, l[0]),
            mapl(f, l[1])
          ];
  } else {
    return /* [] */0;
  }
}

exports.take = take;
exports.drop = drop;
exports.$$double = $$double;
exports.map = map;
exports.halve = halve;
exports.greater = greater;
exports.merge = merge;
exports.msort = msort;
exports.calm = calm;
exports.calm2 = calm2;
exports.clip = clip;
exports.clipList = clipList;
exports.apply = apply;
exports.filter = filter;
exports.for_all = for_all;
exports.mapl = mapl;
/* No side effect */
