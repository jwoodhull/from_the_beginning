// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");

function take(n, l) {
  if (l && n > 0) {
    return /* :: */[
            l[0],
            take(n - 1 | 0, l[1])
          ];
  } else {
    return /* [] */0;
  }
}

function drop(_n, _l) {
  while(true) {
    var l = _l;
    var n = _n;
    if (l && n > 0) {
      _l = l[1];
      _n = n - 1 | 0;
      continue ;
      
    } else {
      return l;
    }
  };
}

function insert(x, l) {
  if (l) {
    var t = l[1];
    var h = l[0];
    if (Caml_obj.caml_lessthan(x, h)) {
      return /* :: */[
              x,
              /* :: */[
                h,
                t
              ]
            ];
    } else {
      return /* :: */[
              h,
              insert(x, t)
            ];
    }
  } else {
    return /* :: */[
            x,
            /* [] */0
          ];
  }
}

function merge(x, y) {
  if (x) {
    if (y) {
      var ty = y[1];
      var hy = y[0];
      var tx = x[1];
      var hx = x[0];
      if (Caml_obj.caml_lessthan(hx, hy)) {
        return /* :: */[
                hx,
                merge(tx, /* :: */[
                      hy,
                      ty
                    ])
              ];
      } else {
        return /* :: */[
                hy,
                merge(/* :: */[
                      hx,
                      tx
                    ], ty)
              ];
      }
    } else {
      return x;
    }
  } else {
    return y;
  }
}

function msort(l) {
  if (l) {
    if (l[1]) {
      var left = take(List.length(l) / 2 | 0, l);
      var right = drop(List.length(l) / 2 | 0, l);
      return merge(msort(left), msort(right));
    } else {
      return /* :: */[
              l[0],
              /* [] */0
            ];
    }
  } else {
    return /* [] */0;
  }
}

function sort(l) {
  if (l) {
    var t = l[1];
    var x = l[0];
    if (t) {
      return insert(x, sort(t));
    } else {
      return /* :: */[
              x,
              /* [] */0
            ];
    }
  } else {
    return /* [] */0;
  }
}

exports.take = take;
exports.drop = drop;
exports.insert = insert;
exports.merge = merge;
exports.msort = msort;
exports.sort = sort;
/* No side effect */
