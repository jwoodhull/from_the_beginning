// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function fst(param) {
  return param[0];
}

function snd(param) {
  return param[1];
}

function lookup(x, _l) {
  while(true) {
    var l = _l;
    if (l) {
      var h = l[0];
      if (h[0] === x) {
        return h[1];
      } else {
        _l = l[1];
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function add(k, v, d) {
  if (d) {
    var t = d[1];
    var match = d[0];
    var k$prime = match[0];
    if (k === k$prime) {
      return /* :: */[
              /* tuple */[
                k,
                v
              ],
              t
            ];
    } else {
      return /* :: */[
              /* tuple */[
                k$prime,
                match[1]
              ],
              add(k, v, t)
            ];
    }
  } else {
    return /* :: */[
            /* tuple */[
              k,
              v
            ],
            /* [] */0
          ];
  }
}

function remove(k, _d) {
  while(true) {
    var d = _d;
    if (d) {
      var t = d[1];
      var h = d[0];
      if (k === h[0]) {
        _d = t;
        continue ;
        
      } else {
        return /* :: */[
                h,
                remove(k, t)
              ];
      }
    } else {
      return /* [] */0;
    }
  };
}

function key_exists(k, d) {
  try {
    lookup(k, d);
    return /* true */1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function uniqueKeys(_d) {
  while(true) {
    var d = _d;
    if (d) {
      var t = d[1];
      if (key_exists(d[0][0], t)) {
        _d = t;
        continue ;
        
      } else {
        return 1 + uniqueKeys(t) | 0;
      }
    } else {
      return 0;
    }
  };
}

function replace(k, v, d) {
  if (d) {
    var t = d[1];
    var match = d[0];
    var k$prime = match[0];
    if (k === k$prime) {
      return /* :: */[
              /* tuple */[
                k,
                v
              ],
              t
            ];
    } else {
      return /* :: */[
              /* tuple */[
                k$prime,
                match[1]
              ],
              replace(k, v, t)
            ];
    }
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function inverse(d) {
  if (d) {
    var match = d[0];
    var match$1 = inverse(d[1]);
    return /* tuple */[
            /* :: */[
              match[0],
              match$1[0]
            ],
            /* :: */[
              match[1],
              match$1[1]
            ]
          ];
  } else {
    return /* tuple */[
            /* [] */0,
            /* [] */0
          ];
  }
}

function toDict(_pairs, _$staropt$star, _param) {
  while(true) {
    var $staropt$star = _$staropt$star;
    var pairs = _pairs;
    var d = $staropt$star ? $staropt$star[0] : /* [] */0;
    if (pairs) {
      var t = pairs[1];
      var match = pairs[0];
      var k = match[0];
      if (key_exists(k, d)) {
        _param = /* () */0;
        _$staropt$star = /* Some */[d];
        _pairs = t;
        continue ;
        
      } else {
        _param = /* () */0;
        _$staropt$star = /* Some */[add(k, match[1], d)];
        _pairs = t;
        continue ;
        
      }
    } else {
      return d;
    }
  };
}

function union(a, b) {
  var joined = Pervasives.$at(a, b);
  return toDict(joined, /* None */0, /* () */0);
}

var census = /* :: */[
  /* tuple */[
    1,
    4
  ],
  /* :: */[
    /* tuple */[
      2,
      2
    ],
    /* :: */[
      /* tuple */[
        3,
        2
      ],
      /* :: */[
        /* tuple */[
          4,
          3
        ],
        /* :: */[
          /* tuple */[
            5,
            1
          ],
          /* :: */[
            /* tuple */[
              6,
              2
            ],
            /* [] */0
          ]
        ]
      ]
    ]
  ]
];

exports.fst = fst;
exports.snd = snd;
exports.census = census;
exports.lookup = lookup;
exports.add = add;
exports.remove = remove;
exports.key_exists = key_exists;
exports.uniqueKeys = uniqueKeys;
exports.replace = replace;
exports.inverse = inverse;
exports.toDict = toDict;
exports.union = union;
/* No side effect */
