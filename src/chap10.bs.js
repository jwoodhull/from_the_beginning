// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");

function component(c) {
  if (typeof c === "number") {
    switch (c) {
      case 0 : 
          return /* tuple */[
                  255,
                  0,
                  0
                ];
      case 1 : 
          return /* tuple */[
                  0,
                  0,
                  255
                ];
      case 2 : 
          return /* tuple */[
                  0,
                  255,
                  0
                ];
      case 3 : 
          return /* tuple */[
                  255,
                  255,
                  0
                ];
      
    }
  } else {
    return /* tuple */[
            c[0],
            c[1],
            c[2]
          ];
  }
}

function lookup_opt(x, _l) {
  while(true) {
    var l = _l;
    if (l) {
      var match = l[0];
      if (Caml_obj.caml_equal(x, match[0])) {
        return /* Some */[match[1]];
      } else {
        _l = l[1];
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function length(l) {
  if (l) {
    return 1 + length(l[1]) | 0;
  } else {
    return 0;
  }
}

function append(a, b) {
  if (a) {
    return /* Cons */[
            a[0],
            append(a[1], b)
          ];
  } else {
    return b;
  }
}

function take(l, s) {
  if (l === 0) {
    return /* Nil */0;
  } else if (s) {
    return /* Cons */[
            s[0],
            take(l - 1 | 0, s[1])
          ];
  } else {
    return s;
  }
}

function map(f, s) {
  if (s) {
    return /* Cons */[
            Curry._1(f, s[0]),
            map(f, s[1])
          ];
  } else {
    return s;
  }
}

function evaluate(e) {
  switch (e.tag | 0) {
    case 0 : 
        return e[0];
    case 1 : 
        return evaluate(e[0]) + evaluate(e[1]) | 0;
    case 2 : 
        return evaluate(e[0]) - evaluate(e[1]) | 0;
    case 3 : 
        return Caml_int32.imul(evaluate(e[0]), evaluate(e[1]));
    case 4 : 
        return Caml_int32.div(evaluate(e[0]), evaluate(e[1]));
    
  }
}

function area(r) {
  if (r.tag) {
    var x = r[0];
    return Caml_int32.imul(x, x);
  } else {
    return Caml_int32.imul(r[0], r[1]);
  }
}

function rotate(r) {
  if (r.tag) {
    return r;
  } else {
    var y = r[1];
    var x = r[0];
    if (x > y) {
      return /* Rect */Block.__(0, [
                y,
                x
              ]);
    } else {
      return r;
    }
  }
}

function getX(r) {
  return r[0];
}

function sortTuple(r, r$prime) {
  return /* tuple */[
          r[0],
          r$prime[0]
        ];
}

function compareList(r, r$prime) {
  var t = sortTuple(r, r$prime);
  var x$prime = t[1];
  var x = t[0];
  if (x === x$prime) {
    return 0;
  } else if (x > x$prime) {
    return 1;
  } else {
    return -1;
  }
}

function totalWidth(l) {
  return List.sort(compareList, List.map(rotate, l));
}

var dic = /* :: */[
  /* tuple */[
    /* "a" */97,
    /* "e" */101
  ],
  /* :: */[
    /* tuple */[
      /* "b" */98,
      /* "r" */114
    ],
    /* [] */0
  ]
];

var list = /* Cons */[
  1,
  /* Cons */[
    2,
    /* Cons */[
      3,
      /* Nil */0
    ]
  ]
];

var exp = /* Add */Block.__(1, [
    /* Num */Block.__(0, [1]),
    /* Multiply */Block.__(3, [
        /* Num */Block.__(0, [2]),
        /* Num */Block.__(0, [3])
      ])
  ]);

var rects = /* :: */[
  /* Square */Block.__(1, [3]),
  /* :: */[
    /* Rect */Block.__(0, [
        4,
        2
      ]),
    /* :: */[
      /* Rect */Block.__(0, [
          1,
          2
        ]),
      /* [] */0
    ]
  ]
];

exports.component = component;
exports.lookup_opt = lookup_opt;
exports.dic = dic;
exports.length = length;
exports.append = append;
exports.take = take;
exports.map = map;
exports.list = list;
exports.evaluate = evaluate;
exports.exp = exp;
exports.area = area;
exports.rotate = rotate;
exports.getX = getX;
exports.sortTuple = sortTuple;
exports.compareList = compareList;
exports.totalWidth = totalWidth;
exports.rects = rects;
/* No side effect */
